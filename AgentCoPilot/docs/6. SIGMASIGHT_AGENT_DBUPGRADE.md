This document captures the database changes for SigmaSight’s AI agent to allow for a learning engine

What “learning” actually means here

For what we’ve been designing, the model doesn’t “learn” by changing its weights; it learns by:

RAG / knowledge base

Storing docs, FAQs, tool docs, and curated answers.

Retrieving the most relevant chunks and feeding them into the prompt.

Memory / preferences

Saving persistent rules like “this user prefers brief answers” or “tenant default currency = EUR”.

Logs & feedback

Logging conversations, tool calls, and user feedback.

Using those logs offline to improve prompts, docs, and rules.

All of that is just data. You’re already great at storing data: that’s what your Postgres is doing.

2. Recommended: reuse your existing Postgres
Why stay on the same DB?

You already have:

agent.CONVERSATIONS, agent.MESSAGES

AI_INSIGHTS, AI_INSIGHT_TEMPLATES

Portfolio/position tables for context

You want to be able to join things like:

“Show me all conversations for portfolio X with volatility above Y”

“Cluster questions where positions had options exposure”

You already have migrations, backups, observability, and user/tenant scoping in this DB.

So the simplest, cleanest path is:

Add a few AI-specific tables + pgvector to the existing Postgres instance.

No new infra, no cross‑DB headaches.

3. What to add to your existing Postgres

Here’s the minimal set I’d add (all within the same DB, maybe under an ai schema):

3.1 Knowledge base (RAG)
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE ai_kb_documents (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  scope       text NOT NULL,   -- 'global', 'page:portfolio-overview', 'tenant:XYZ', etc.
  title       text NOT NULL,
  content     text NOT NULL,
  metadata    jsonb NOT NULL DEFAULT '{}'::jsonb,
  embedding   vector(1536),
  created_at  timestamptz NOT NULL DEFAULT now(),
  updated_at  timestamptz NOT NULL DEFAULT now()
);


Use case: store tool docs, domain write‑ups, curated answers.

At query time: embed question → vector search on embedding → feed top K docs into prompt.

3.2 Memory / rules (optional but nice)
CREATE TABLE ai_memories (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id     uuid,
  tenant_id   uuid,
  scope       text NOT NULL,        -- 'user', 'tenant', 'global'
  content     text NOT NULL,        -- short rule or fact
  tags        jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at  timestamptz NOT NULL DEFAULT now()
);


Use case: store persistent instructions:

“Do not give tax advice”

“Default benchmark for this client is 60/40”

Pulled into the system message before each call.

3.3 Feedback (for “learning from users”)
CREATE TABLE ai_feedback (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id  uuid NOT NULL,      -- references agent.MESSAGES.id
  rating      text NOT NULL,      -- 'up' | 'down'
  edited_text text,
  created_at  timestamptz NOT NULL DEFAULT now()
);


Use case: thumbs up/down on chat messages or insights.

Used offline to:

find bad answers,

create better KB docs,

tweak prompts or tools.

All of these live happily next to your existing tables; they don’t require a new DB.

